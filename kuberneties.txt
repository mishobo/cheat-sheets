# install kubeadm
> sudo apt-get update
> sudo apt-get install -y docker.io
cat <<EOF | sudo tee /etc/modules-load.d/containerd.conf
overlay
br_netfilter
EOF
> sudo modprobe overlay
> sudo modprobe br_netfilter
cat <<EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
net.bridge.bridge-nf-call-ip6tables = 1
EOF
> sudo sysctl --system
> sudo apt-get update && sudo apt-get install -y containerd
> sudo mkdir -p /etc/containerd
> containerd config default | sudo tee /etc/containerd/config.toml
> sudo systemctl restart containerd
> sudo systemctl status containerd
> sudo swapoff -a
> sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
> sudo apt-get update && sudo apt-get install -y apt-transport-https ca-certificates curl
> sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://dl.k8s.io/apt/doc/apt-key.gpg
> echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
> sudo apt-get update
> sudo apt-get install -y kubelet kubeadm kubectl
> sudo apt-mark hold kubelet kubeadm kubectl
# create kuberneties cluster/ master node
> kubeadm init --pod-network-cidr=192.168.0.0/16

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

export KUBECONFIG=/etc/kubernetes/admin.conf 

# token generated
kubeadm join 143.198.65.88:6443 --token edl9oo.bnwmloh28ec0r5oa \
        --discovery-token-ca-cert-hash sha256:53bc72f721a1aff6d74c25a293604b53632d760d0a34f2a5aa4a5e7877bc2ec9 

> kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml
> kubectl get pods --all-namespaces

# creating token for joining nodes
> kubeadm token create --print-join-command
> kubeadm token list

# drain a k8s node
> kubectl drain <node_name> --ignore-daemonsets --force

# rejoin a drained node
> kubectl uncordon <node_name>

# upgrade k8s master
1. Drain control plane
2. Plan the upgrade
3. apply the upgrade
4. upgrade kubectl & kubelet on control plane node
5. uncordon the node

> kubectl get nodes
> kubectl drain k8s-master-node --ignore-daemonsets
> sudo apt-get install -y --allow-change-held-package kubeadm=1.21.1-00
> kubeadm version
> sudo kubeadm upgrade plan v1.21.1-00
> kubeadm upgrade apply v1.21.1-00
> sudo apt-get update
> sudo systemctl daemon-reload
> sudo systemctl restart kubelet
> kubectl get nodes
> kubectl uncordon k8s-master-node

# upgrade k8s worker
1. upgrade worker node
2. drain worker node
3. upgrade kubeadm
4. upgrade kubelet config
5. upgrade kubectl and kubelet
6. uncordon the node

> kubectl drain <node-to-drain> --ignore-daemonsets --force
> sudo apt-get update
> sudo apt-get install -y --allow-change-held-packages kubeadm=1.21.1-00
> kubeadm version
> sudo kubeadm upgrade node
> sudo apt-get update
> sudo apt-get install -y --allow-change-held-packages kubelet=1.21.1-00 kubectl=1.21.1-00
> sudo systemctl daemon-reload
> sudo systemctl restart kubelet
> kubectl get nodes
> kubectl uncordon <node-to-uncordon>


# unistall kuberneties
> kubeadm reset
> apt-get purge kubeadm kubectl kubelet kubernetes-cni kube* 
> sudo apt-get autoremove

# start minikube
> minikube start --force
> kubectl version --client
> sudo apt install conntrack
> sudo minikube start --vm-driver=none

# get cluster information
> kubectl config view

# create deployment
> kubectl create deployment hello-node --image=k8s.gcr.io/echoserver:1.4
> kubectl get deployment
> kubectl delete deployment deploymentName

# get pods
> kubectl get pods

# expose cluster externally
> kubectl expose deployment hello-node --type=LoadBalancer --port=8080
> kubectl get services
> minikube service hello-node
> kubectl delete service serviceName

# namespace comands
> kubectl get namespaces
> kubectl get pods --namespace <namespace>
> kubectl create namespace <namespace>

 

> doctl auth init --context <NAME>
> doctl auth list
> doctl auth switch --context <NAME>
> doctl account get
> doctl serverless install
> doctl compute droplet create --region sfo2 --image ubuntu-18-04-x64 --size s-1vcpu-1gb <DROPLET-NAME>



> kubectl get namespaces
> kubectl create --namespace frontend
> kubectl config current-context
> kubectl config get-contexts
> kubectl config use-context <CONTEXT_NAME>
> kubectl logs <name> -n backend -f

# deploying springboot image
> mvn clean install 
> docker build -t claims-apis .
> docker build -t registry.digitalocean.com/lct-registry/claims-apis:202307061535 .
> docker tag claims-apis registry.digitalocean.com/lct-registry/claims-apis:202307061535
> docker push registry.digitalocean.com/lct-registry/claims-apis:202307061535
> digest: sha256:2fa9fd41a357b11b83a9ab42626502aa0d2ced761a0d6745e76b53d8f6c5a7f4 
> kubectl apply -f .\.k8_manifest\claims-deployment.yaml
> kubectl get pods -n backend -o wide
> kubectl exec -n backend utilities-54c9897fdb-dr66v -it -- /bin/sh